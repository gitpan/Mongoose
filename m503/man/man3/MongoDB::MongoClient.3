.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MongoDB::MongoClient 3"
.TH MongoDB::MongoClient 3 "2013-01-07" "perl v5.14.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MongoDB::MongoClient \- A connection to a Mongo server
.SH "VERSION"
.IX Header "VERSION"
version 0.503.3
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The MongoDB::MongoClient class creates a client connection to the MongoDB server.
.PP
By default, it connects to a single server running on the local machine
listening on the default port:
.PP
.Vb 2
\&    # connects to localhost:27017
\&    my $client = MongoDB::MongoClient\->new;
.Ve
.PP
It can connect to a database server running anywhere, though:
.PP
.Vb 1
\&    my $client = MongoDB::MongoClient\->new(host => \*(Aqexample.com:12345\*(Aq);
.Ve
.PP
See the \*(L"host\*(R" section for more options for connecting to MongoDB.
.SS "Multithreading"
.IX Subsection "Multithreading"
Cloning instances of this class is disabled in Perl 5.8.7+, so forked threads
will have to create their own connections to the database.
.SH "NAME"
MongoDB::MongoClient \- A client object for a MongoDB server
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Core documentation on connections: <http://dochub.mongodb.org/core/connections>.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "host"
.IX Subsection "host"
Server or servers to connect to. Defaults to \f(CW\*(C`mongodb://localhost:27017\*(C'\fR.
.PP
To connect to more than one database server, use the format:
.PP
.Vb 1
\&    mongodb://host1[:port1][,host2[:port2],...[,hostN[:portN]]]
.Ve
.PP
An arbitrary number of hosts can be specified.
.PP
The connect method will return success if it can connect to at least one of the
hosts listed.  If it cannot connect to any hosts, it will die.
.PP
If a port is not specified for a given host, it will default to 27017. For
example, to connecting to \f(CW\*(C`localhost:27017\*(C'\fR and \f(CW\*(C`localhost:27018\*(C'\fR:
.PP
.Vb 1
\&    my $client = MongoDB::MongoClient\->new("host" => "mongodb://localhost,localhost:27018");
.Ve
.PP
This will succeed if either \f(CW\*(C`localhost:27017\*(C'\fR or \f(CW\*(C`localhost:27018\*(C'\fR are available.
.PP
The connect method will also try to determine who is the primary if more than one
server is given.  It will try the hosts in order from left to right.  As soon as
one of the hosts reports that it is the primary, the connect will return success.  If
no hosts report themselves as a primary, the connect will die.
.PP
If username and password are given, success is conditional on being able to log
into the database as well as connect.  By default, the driver will attempt to
authenticate with the admin database.  If a different database is specified
using the \f(CW\*(C`db_name\*(C'\fR property, it will be used instead.
.SS "w"
.IX Subsection "w"
The client \fIwrite concern\fR.
.ie n .IP """\-1"" Errors ignored. Do not use this. =item 0 Unacknowledged. MongoClient will \fB\s-1NOT\s0\fR wait for an acknowledgment that the server has received and processed the request. Older documentation may refer to this as ""fire-and-forget"" mode. You must call ""getLastError"" manually to check if a request succeeds. This option is not recommended. =item 1 Acknowledged. This is the default. MongoClient will wait until the primary MongoDB acknowledges the write. =item 2 Replica acknowledged. MongoClient will wait until at least two replicas (primary and one secondary) acknowledge the write. You can set a higher number for more replicas. =item ""all"" All replicas acknowledged. =item ""majority"" A majority of replicas acknowledged." 4
.el .IP "\f(CW\-1\fR Errors ignored. Do not use this. =item \f(CW0\fR Unacknowledged. MongoClient will \fB\s-1NOT\s0\fR wait for an acknowledgment that the server has received and processed the request. Older documentation may refer to this as ``fire-and-forget'' mode. You must call \f(CWgetLastError\fR manually to check if a request succeeds. This option is not recommended. =item \f(CW1\fR Acknowledged. This is the default. MongoClient will wait until the primary MongoDB acknowledges the write. =item \f(CW2\fR Replica acknowledged. MongoClient will wait until at least two replicas (primary and one secondary) acknowledge the write. You can set a higher number for more replicas. =item \f(CWall\fR All replicas acknowledged. =item \f(CWmajority\fR A majority of replicas acknowledged." 4
.IX Item "-1 Errors ignored. Do not use this. =item 0 Unacknowledged. MongoClient will NOT wait for an acknowledgment that the server has received and processed the request. Older documentation may refer to this as fire-and-forget mode. You must call getLastError manually to check if a request succeeds. This option is not recommended. =item 1 Acknowledged. This is the default. MongoClient will wait until the primary MongoDB acknowledges the write. =item 2 Replica acknowledged. MongoClient will wait until at least two replicas (primary and one secondary) acknowledge the write. You can set a higher number for more replicas. =item all All replicas acknowledged. =item majority A majority of replicas acknowledged."
In MongoDB v2.0+, you can \*(L"tag\*(R" replica members. With \*(L"tagging\*(R" you can specify a 
new \*(L"getLastErrorMode\*(R" where you can create new
rules on how your data is replicated. To used you getLastErrorMode, you pass in the 
name of the mode to the \f(CW\*(C`w\*(C'\fR parameter. For more infomation see: 
http://www.mongodb.org/display/DOCS/Data+Center+Awareness
.SS "wtimeout"
.IX Subsection "wtimeout"
The number of milliseconds an operation should wait for \f(CW\*(C`w\*(C'\fR slaves to replicate
it.
.PP
Defaults to 1000 (1 second).
.PP
See \f(CW\*(C`w\*(C'\fR above for more information.
.SS "j"
.IX Subsection "j"
If true, awaits the journal commit before returning. If the server is running without 
journaling, it returns immediately, and successfully.
.SS "auto_reconnect"
.IX Subsection "auto_reconnect"
Boolean indicating whether or not to reconnect if the connection is
interrupted. Defaults to \f(CW1\fR.
.SS "auto_connect"
.IX Subsection "auto_connect"
Boolean indication whether or not to connect automatically on object
construction. Defaults to \f(CW1\fR.
.SS "timeout"
.IX Subsection "timeout"
Connection timeout in milliseconds. Defaults to \f(CW20000\fR.
.SS "username"
.IX Subsection "username"
Username for this client connection.  Optional.  If this and the password field are
set, the client will attempt to authenticate on connection/reconnection.
.SS "password"
.IX Subsection "password"
Password for this connection.  Optional.  If this and the username field are
set, the client will attempt to authenticate on connection/reconnection.
.SS "db_name"
.IX Subsection "db_name"
Database to authenticate on for this connection.  Optional.  If this, the
username, and the password fields are set, the client will attempt to
authenticate against this database on connection/reconnection.  Defaults to
\&\*(L"admin\*(R".
.SS "query_timeout"
.IX Subsection "query_timeout"
.Vb 2
\&    # set query timeout to 1 second
\&    my $client = MongoDB::MongoClient\->new(query_timeout => 1000);
\&
\&    # set query timeout to 6 seconds
\&    $client\->query_timeout(6000);
.Ve
.PP
This will cause all queries (including \f(CW\*(C`find_one\*(C'\fRs and \f(CW\*(C`run_command\*(C'\fRs) to die
after this period if the database has not responded.
.PP
This value is in milliseconds and defaults to the value of
\&\*(L"timeout\*(R" in MongoDB::Cursor.
.PP
.Vb 3
\&    $MongoDB::Cursor::timeout = 5000;
\&    # query timeout for $conn will be 5 seconds
\&    my $client = MongoDB::MongoClient\->new;
.Ve
.PP
A value of \-1 will cause the driver to wait forever for responses and 0 will
cause it to die immediately.
.PP
This value overrides \*(L"timeout\*(R" in MongoDB::Cursor.
.PP
.Vb 3
\&    $MongoDB::Cursor::timeout = 1000;
\&    my $client = MongoDB::MongoClient\->new(query_timeout => 10);
\&    # timeout for $conn is 10 milliseconds
.Ve
.SS "max_bson_size"
.IX Subsection "max_bson_size"
This is the largest document, in bytes, storable by MongoDB. The driver queries
MongoDB on connection to determine this value.  It defaults to 4MB.
.SS "find_master"
.IX Subsection "find_master"
If this is true, the driver will attempt to find a primary given the list of
hosts.  The primary-finding algorithm looks like:
.PP
.Vb 1
\&    for host in hosts
\&
\&        if host is the primary
\&             return host
\&
\&        else if host is a replica set member
\&            primary := replica set\*(Aqs primary
\&            return primary
.Ve
.PP
If no primary is found, the connection will fail.
.PP
If this is not set (or set to the default, 0), the driver will simply use the
first host in the host list for all connections.  This can be useful for
directly connecting to secondaries for reads.
.PP
If you are connecting to a secondary, you should read
\&\*(L"slave_okay\*(R" in MongoDB::Cursor.
.PP
You can use the \f(CW\*(C`ismaster\*(C'\fR command to find the members of a replica set:
.PP
.Vb 1
\&    my $result = $db\->run_command({ismaster => 1});
.Ve
.PP
The primary and secondary hosts are listed in the \f(CW\*(C`hosts\*(C'\fR field, the slaves are
in the \f(CW\*(C`passives\*(C'\fR field, and arbiters are in the \f(CW\*(C`arbiters\*(C'\fR field.
.SS "ssl"
.IX Subsection "ssl"
This tells the driver that you are connecting to an \s-1SSL\s0 mongodb instance.
.PP
This option will be ignored if the driver was not compiled with the \s-1SSL\s0 flag. You must
also be using a database server that supports \s-1SSL\s0.
.SS "dt_type"
.IX Subsection "dt_type"
Sets the type of object which is returned for DateTime fields. The default is DateTime. Other
acceptable values are DateTime::Tiny and \f(CW\*(C`undef\*(C'\fR. The latter will give you the raw epoch value
rather than an object.
.SH "METHODS"
.IX Header "METHODS"
.SS "connect"
.IX Subsection "connect"
.Vb 1
\&    $client\->connect;
.Ve
.PP
Connects to the MongoDB server. Called automatically on object construction if
\&\f(CW\*(C`auto_connect\*(C'\fR is true.
.SS "database_names"
.IX Subsection "database_names"
.Vb 1
\&    my @dbs = $client\->database_names;
.Ve
.PP
Lists all databases on the mongo server.
.SS "get_database($name)"
.IX Subsection "get_database($name)"
.Vb 1
\&    my $database = $client\->get_database(\*(Aqfoo\*(Aq);
.Ve
.PP
Returns a MongoDB::Database instance for database with the given \f(CW$name\fR.
.SS "get_master"
.IX Subsection "get_master"
.Vb 1
\&    $master = $client\->get_master
.Ve
.PP
Determines which host of a paired connection is master.  Does nothing for
a non-paired connection.  This need never be invoked by a user, it is
called automatically by internal functions.  Returns the index of the master
connection in the list of connections or \-1 if it cannot be determined.
.ie n .SS "authenticate ($dbname, $username, $password, $is_digest?)"
.el .SS "authenticate ($dbname, \f(CW$username\fP, \f(CW$password\fP, \f(CW$is_digest\fP?)"
.IX Subsection "authenticate ($dbname, $username, $password, $is_digest?)"
.Vb 1
\&    $client\->authenticate(\*(Aqfoo\*(Aq, \*(Aqusername\*(Aq, \*(Aqsecret\*(Aq);
.Ve
.PP
Attempts to authenticate for use of the \f(CW$dbname\fR database with \f(CW$username\fR
and \f(CW$password\fR. Passwords are expected to be cleartext and will be
automatically hashed before sending over the wire, unless \f(CW$is_digest\fR is
true, which will assume you already did the hashing on yourself.
.PP
See also the core documentation on authentication:
<http://dochub.mongodb.org/core/authentication>.
.SS "send($str)"
.IX Subsection "send($str)"
.Vb 2
\&    my ($insert, $ids) = MongoDB::write_insert(\*(Aqfoo.bar\*(Aq, [{name => "joe", age => 40}]);
\&    $client\->send($insert);
.Ve
.PP
Low-level function to send a string directly to the database.  Use
MongoDB::write_insert, MongoDB::write_update, MongoDB::write_remove, or
MongoDB::write_query to create a valid string.
.SS "recv(\e%info)"
.IX Subsection "recv(%info)"
.Vb 1
\&    my $cursor = $client\->recv({ns => "foo.bar"});
.Ve
.PP
Low-level function to receive a response from the database. Returns a
\&\f(CW\*(C`MongoDB::Cursor\*(C'\fR.  At the moment, the only required field for \f(CW$info\fR is
\&\*(L"ns\*(R", although \*(L"request_id\*(R" is likely to be required in the future.  The
\&\f(CW$info\fR hash will be automatically created for you by MongoDB::write_query.
.PP
.Vb 1
\&    $client\->fsync();
.Ve
.PP
A function that will forces the server to flush all pending writes to the storage layer.
.PP
The fsync operation is synchronous by default, to run fsync asynchronously, use the following form:
.PP
.Vb 1
\&    $client\->fsync({async => 1});
.Ve
.PP
The primary use of fsync is to lock the database during backup operations. This will flush all data to the data storage layer and block all write operations until you unlock the database. Note: you can still read while the database is locked.
.PP
.Vb 1
\&    $conn\->fsync({lock => 1});
.Ve
.PP
.Vb 1
\&    $conn\->fsync_unlock();
.Ve
.PP
Unlocks a database server to allow writes and reverses the operation of a \f(CW$conn\fR\->fsync({lock => 1}); operation.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Kristina Chodorow <kristina@mongodb.org>
.IP "\(bu" 4
Mike Friedman <mike.friedman@10gen.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by 10gen, Inc..
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 539:" 4
.IX Item "Around line 539:"
You forgot a '=back' before '=head2'
.IP "Around line 719:" 4
.IX Item "Around line 719:"
Unknown directive: =head
.IP "Around line 733:" 4
.IX Item "Around line 733:"
Unknown directive: =head
