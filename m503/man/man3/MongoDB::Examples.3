.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MongoDB::Examples 3"
.TH MongoDB::Examples 3 "2013-01-07" "perl v5.14.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MongoDB::Examples \- Some examples of MongoDB syntax
.SH "VERSION"
.IX Header "VERSION"
version 0.503.3
.SH "MAPPING SQL TO MONGODB"
.IX Header "MAPPING SQL TO MONGODB"
For developers familiar with \s-1SQL\s0, the following chart should help you see how
many common \s-1SQL\s0 queries could be expressed in MongoDB.
.PP
These are Perl-specific examples of translating \s-1SQL\s0 queries to MongoDB's query
language.  To see the JavaScript (or other languages') mappings, see
<http://dochub.mongodb.org/core/sqlToMongo>.
.PP
In the following examples, \f(CW$db\fR is a MongoDB::Database object which was
retrieved by using \f(CW\*(C`get_database\*(C'\fR. See MongoDB::MongoClient for more.
.ie n .IP """CREATE TABLE USERS (a Number, b Number)""" 4
.el .IP "\f(CWCREATE TABLE USERS (a Number, b Number)\fR" 4
.IX Item "CREATE TABLE USERS (a Number, b Number)"
.Vb 1
\&    Implicit, can be done explicitly.
.Ve
.ie n .IP """INSERT INTO USERS VALUES(1,1)""" 4
.el .IP "\f(CWINSERT INTO USERS VALUES(1,1)\fR" 4
.IX Item "INSERT INTO USERS VALUES(1,1)"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->insert( { a => 1, b => 1 } );
.Ve
.ie n .IP """SELECT a,b FROM users""" 4
.el .IP "\f(CWSELECT a,b FROM users\fR" 4
.IX Item "SELECT a,b FROM users"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq)\->find( { }, { a => 1, b => 1 } );
.Ve
.ie n .IP """SELECT * FROM users""" 4
.el .IP "\f(CWSELECT * FROM users\fR" 4
.IX Item "SELECT * FROM users"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find;
.Ve
.ie n .IP """SELECT * FROM users WHERE age=33""" 4
.el .IP "\f(CWSELECT * FROM users WHERE age=33\fR" 4
.IX Item "SELECT * FROM users WHERE age=33"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { age => 33 } )
.Ve
.ie n .IP """SELECT a,b FROM users WHERE age=33""" 4
.el .IP "\f(CWSELECT a,b FROM users WHERE age=33\fR" 4
.IX Item "SELECT a,b FROM users WHERE age=33"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { age => 33 }, { a => 1, b => 1 } );
.Ve
.ie n .IP """SELECT * FROM users WHERE age=33 ORDER BY name""" 4
.el .IP "\f(CWSELECT * FROM users WHERE age=33 ORDER BY name\fR" 4
.IX Item "SELECT * FROM users WHERE age=33 ORDER BY name"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { age => 33 } )\->sort( { name => 1 } );
.Ve
.ie n .IP """<SELECT * FROM users WHERE age""33>>" 4
.el .IP "\f(CW<SELECT * FROM users WHERE age\fR33>>" 4
.IX Item "<SELECT * FROM users WHERE age33>>"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { age => { \*(Aq$gt\*(Aq => 33 } } );
.Ve
.ie n .IP """<SELECT * FROM users WHERE age<33"">" 4
.el .IP "\f(CW<SELECT * FROM users WHERE age<33\fR>" 4
.IX Item "<SELECT * FROM users WHERE age<33>"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { age => { \*(Aq$lt\*(Aq => 33 } } );
.Ve
.ie n .IP """SELECT * FROM users WHERE name LIKE ""%Joe%""""" 4
.el .IP "\f(CWSELECT * FROM users WHERE name LIKE ``%Joe%''\fR" 4
.IX Item "SELECT * FROM users WHERE name LIKE ""%Joe%"""
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { name => qr/Joe/ } );
.Ve
.ie n .IP """SELECT * FROM users WHERE name LIKE ""Joe%""""" 4
.el .IP "\f(CWSELECT * FROM users WHERE name LIKE ``Joe%''\fR" 4
.IX Item "SELECT * FROM users WHERE name LIKE ""Joe%"""
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( {name => qr/^Joe/ } );
.Ve
.ie n .IP """<SELECT * FROM users WHERE age""33 \s-1AND\s0 age<=40>>" 4
.el .IP "\f(CW<SELECT * FROM users WHERE age\fR33 \s-1AND\s0 age<=40>>" 4
.IX Item "<SELECT * FROM users WHERE age33 AND age<=40>>"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { age => { \*(Aq$gt\*(Aq => 33, \*(Aq$lte\*(Aq => 40 } } );
.Ve
.ie n .IP """SELECT * FROM users ORDER BY name DESC""" 4
.el .IP "\f(CWSELECT * FROM users ORDER BY name DESC\fR" 4
.IX Item "SELECT * FROM users ORDER BY name DESC"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find\->sort( { name => \-1 } );
.Ve
.ie n .IP """CREATE INDEX myindexname ON users(name)""" 4
.el .IP "\f(CWCREATE INDEX myindexname ON users(name)\fR" 4
.IX Item "CREATE INDEX myindexname ON users(name)"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->ensure_index( { name => 1 } );
.Ve
.ie n .IP """CREATE INDEX myindexname ON users(name,ts DESC)""" 4
.el .IP "\f(CWCREATE INDEX myindexname ON users(name,ts DESC)\fR" 4
.IX Item "CREATE INDEX myindexname ON users(name,ts DESC)"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->ensure_index( Tie::IxHash\->new( name => 1, ts => \-1 ) );
.Ve
.Sp
In this example, we must use Tie::IxHash to preserve the ordering of the arguments to 
\&\f(CW\*(C`ensureIndex\*(C'\fR.
.ie n .IP """SELECT * FROM users WHERE a=1 and b=\*(Aqq\*(Aq""" 4
.el .IP "\f(CWSELECT * FROM users WHERE a=1 and b=\*(Aqq\*(Aq\fR" 4
.IX Item "SELECT * FROM users WHERE a=1 and b=q"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( {a => 1, b => "q" } );
.Ve
.ie n .IP """SELECT * FROM users LIMIT 10 SKIP 20""" 4
.el .IP "\f(CWSELECT * FROM users LIMIT 10 SKIP 20\fR" 4
.IX Item "SELECT * FROM users LIMIT 10 SKIP 20"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find\->limit(10)\->skip(20);
.Ve
.ie n .IP """SELECT * FROM users WHERE a=1 or b=2""" 4
.el .IP "\f(CWSELECT * FROM users WHERE a=1 or b=2\fR" 4
.IX Item "SELECT * FROM users WHERE a=1 or b=2"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { \*(Aq$or\*(Aq => [ {a => 1 }, { b => 2 } ] } );
.Ve
.ie n .IP """SELECT * FROM users LIMIT 1""" 4
.el .IP "\f(CWSELECT * FROM users LIMIT 1\fR" 4
.IX Item "SELECT * FROM users LIMIT 1"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find\->limit(1);
.Ve
.ie n .IP """EXPLAIN SELECT * FROM users WHERE z=3""" 4
.el .IP "\f(CWEXPLAIN SELECT * FROM users WHERE z=3\fR" 4
.IX Item "EXPLAIN SELECT * FROM users WHERE z=3"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { z => 3 } )\->explain;
.Ve
.ie n .IP """SELECT DISTINCT last_name FROM users""" 4
.el .IP "\f(CWSELECT DISTINCT last_name FROM users\fR" 4
.IX Item "SELECT DISTINCT last_name FROM users"
.Vb 1
\&    $db\->run_command( { distinct => "users", key => "last_name" } );
.Ve
.ie n .IP """SELECT COUNT(*y) FROM users""" 4
.el .IP "\f(CWSELECT COUNT(*y) FROM users\fR" 4
.IX Item "SELECT COUNT(*y) FROM users"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->count;
.Ve
.ie n .IP """<SELECT COUNT(*y) FROM users where age "" 30>>" 4
.el .IP "\f(CW<SELECT COUNT(*y) FROM users where age \fR 30>>" 4
.IX Item "<SELECT COUNT(*y) FROM users where age  30>>"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { "age" => { \*(Aq$gt\*(Aq => 30 } } )\->count;
.Ve
.ie n .IP """SELECT COUNT(age) from users""" 4
.el .IP "\f(CWSELECT COUNT(age) from users\fR" 4
.IX Item "SELECT COUNT(age) from users"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->find( { age => { \*(Aq$exists\*(Aq => 1 } } )\->count;
.Ve
.ie n .IP """UPDATE users SET a=1 WHERE b=\*(Aqq\*(Aq""" 4
.el .IP "\f(CWUPDATE users SET a=1 WHERE b=\*(Aqq\*(Aq\fR" 4
.IX Item "UPDATE users SET a=1 WHERE b=q"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->update( { b => "q" }, { \*(Aq$set\*(Aq => { a => 1 } } );
.Ve
.ie n .IP """UPDATE users SET a=a+2 WHERE b=\*(Aqq\*(Aq""" 4
.el .IP "\f(CWUPDATE users SET a=a+2 WHERE b=\*(Aqq\*(Aq\fR" 4
.IX Item "UPDATE users SET a=a+2 WHERE b=q"
.Vb 1
\&    $db\->get_collection( \*(Aqusers\*(Aq )\->update( { b => "q" }, { \*(Aq$inc\*(Aq => { a => 2 } } );
.Ve
.ie n .IP """DELETE FROM users WHERE z=""abc""""" 4
.el .IP "\f(CWDELETE FROM users WHERE z=``abc''\fR" 4
.IX Item "DELETE FROM users WHERE z=""abc"""
.Vb 1
\&    $db\->get_database( \*(Aqusers\*(Aq )\->remove( { z => "abc" } );
.Ve
.SH "DATABASE COMMANDS"
.IX Header "DATABASE COMMANDS"
If you do something in the MongoDB shell and you would like to translate it to
Perl, the best way is to run the function in the shell without parentheses, which
will print the source.  You can then generally translate the source into Perl
fairly easily.
.PP
For example, suppose we want to use \f(CW\*(C`db.foo.validate\*(C'\fR in Perl.  We could
run:
.PP
.Vb 10
\&    > db.foo.validate
\&    function (full) {
\&        var cmd = {validate:this.getName()};
\&        if (typeof full == "object") {
\&            Object.extend(cmd, full);
\&        } else {
\&            cmd.full = full;
\&        }
\&        var res = this._db.runCommand(cmd);
\&        if (typeof res.valid == "undefined") {
\&            res.valid = false;
\&            var raw = res.result || res.raw;
\&            if (raw) {
\&                var str = "\-" + tojson(raw);
\&                res.valid = !(str.match(/exception/) || str.match(/corrupt/));
\&                var p = /lastExtentSize:(\ed+)/;
\&                var r = p.exec(str);
\&                if (r) {
\&                    res.lastExtentSize = Number(r[1]);
\&                }
\&            }
\&        }
\&        return res;
\&    }
.Ve
.PP
Thus, we can translate the important parts into Perl:
.PP
.Vb 1
\&    $db\->run_command( { validate => "foo" } );
.Ve
.SS "Distinct"
.IX Subsection "Distinct"
The distinct command returns all values for a given key in a collection.  For
example, suppose we had a collection with the following documents (\f(CW\*(C`_id\*(C'\fR value
ignored):
.PP
.Vb 4
\&    { \*(Aqname\*(Aq => \*(Aqa\*(Aq, code => 1 }
\&    { \*(Aqname\*(Aq => \*(Aqb\*(Aq, code => 1 }
\&    { \*(Aqname\*(Aq => \*(Aqc\*(Aq, code => 2 }
\&    { \*(Aqname\*(Aq => \*(Aqd\*(Aq, code => "3" }
.Ve
.PP
If we wanted to see all of values in the \*(L"code\*(R" field, we could run:
.PP
.Vb 5
\&    my $result = $db\->run_command([
\&       "distinct" => "collection_name",
\&       "key"      => "code",
\&       "query"    => { }
\&    ]);
.Ve
.PP
Notice that the arguments are in an array, to ensure that their order is
preserved.  You could also use a Tie::IxHash.
.PP
\&\f(CW\*(C`query\*(C'\fR is an optional argument, which can be used to only run \f(CW\*(C`distinct\*(C'\fR on
specific documents.  It takes a hash (or Tie::IxHash or array) in the same
form as \*(L"find($query)\*(R" in MongoDB::Collection.
.PP
Running \f(CW\*(C`distinct\*(C'\fR on the above collection would give you:
.PP
.Vb 8
\&    {
\&        \*(Aqok\*(Aq => \*(Aq1\*(Aq,
\&        \*(Aqvalues\*(Aq => [
\&                      1,
\&                      2,
\&                      "3"
\&                    ]
\&    };
.Ve
.SS "Find-and-modify"
.IX Subsection "Find-and-modify"
The find-and-modify command is similar to update (or remove), but it will return
the modified document.  It can be useful for implementing queues or locks.
.PP
For example, suppose we had a list of things to do, and we wanted to remove the
highest-priority item for processing.  We could do a \*(L"find\*(R" in MongoDB::Collection
and then a \*(L"remove\*(R" in MongoDB::Collection, but that wouldn't be atomic (a write
could occur between the query and the remove).  Instead, we can use find and
modify.
.PP
.Vb 5
\&    my $next_task = $db\->run_command({
\&        findAndModify => "todo",
\&        sort => {priority => \-1},
\&        remove => 1
\&    });
.Ve
.PP
This will atomically find and pop the next-highest-priority task.
.PP
See <http://www.mongodb.org/display/DOCS/findAndModify+Command> for more
details on find-and-modify.
.SS "Group"
.IX Subsection "Group"
The group command is similar to \*(L"\s-1GROUP\s0 \s-1BY\s0\*(R" in \s-1SQL\s0.  You can use the
\&\*(L"run_command\*(R" in MongoDB::Database method to perform group-bys with MongoDB.
.PP
For example, suppose we have a number of local businesses stored in a \*(L"business\*(R"
collection.  If we wanted to find the number of coffeeshops in each neighborhood, we
could do:
.PP
.Vb 10
\&    my $reduce = <<REDUCE;
\&    function(doc, prev) {
\&        for (var t in doc.tags) {
\&            if (doc.tags[t] == "coffeeshop") {
\&                prev["num coffeeshops"]++;
\&                break;
\&            }
\&        }
\&    }
\&    REDUCE
\&
\&    my $result = $db\->run_command({group => {
\&        \*(Aqns\*(Aq => "business",
\&        \*(Aqkey\*(Aq => {"neighborhood" => 1},
\&        \*(Aqinitial\*(Aq => {"num coffeeshops" => 0},
\&        \*(Aq$reduce\*(Aq => MongoDB::Code\->new(code => $reduce)
.Ve
.PP
This would return something like:
.PP
.Vb 10
\&    {
\&          \*(Aqok\*(Aq => \*(Aq1\*(Aq,
\&          \*(Aqkeys\*(Aq => 4,
\&          \*(Aqcount\*(Aq => \*(Aq487\*(Aq, # total number of documents
\&          \*(Aqretval\*(Aq => [
\&              {
\&                          \*(Aqneighborhood\*(Aq => \*(AqSoho\*(Aq,
\&                          \*(Aqnum coffeeshops\*(Aq => \*(Aq23\*(Aq
\&              },
\&              {
\&                          \*(Aqneighborhood\*(Aq => \*(AqChinatown\*(Aq,
\&                          \*(Aqnum coffeeshops\*(Aq => \*(Aq14\*(Aq
\&              },
\&              {
\&                          \*(Aqneighborhood\*(Aq => \*(AqUpper East Side\*(Aq,
\&                          \*(Aqnum coffeeshops\*(Aq => \*(Aq10\*(Aq
\&              },
\&              {
\&                          \*(Aqneighborhood\*(Aq => \*(AqEast Village\*(Aq,
\&                          \*(Aqnum coffeeshops\*(Aq => \*(Aq87\*(Aq
\&              }
\&            ]
\&    };
.Ve
.PP
Thus, there are 23 coffeeshops in Soho, 14 in Chinatown, and so on.
.PP
See <http://www.mongodb.org/display/DOCS/Aggregation> for more details on
grouping.
.SS "MapReduce"
.IX Subsection "MapReduce"
MapReduce is a powerful aggregation tool.  (For traditional queries, you should
use \f(CW\*(C`MongoDB::Collection::query\*(C'\fR.)
.PP
This example counts the number of occurences of each tag in a collection.  Each
document contains a \*(L"tags\*(R" array that contains zero or more strings.
.PP
.Vb 7
\&    my $map = <<MAP;
\&    function() {
\&        this.tags.forEach(function(tag) {
\&            emit(tag, {count : 1});
\&        });
\&    }
\&    MAP
\&
\&    my $reduce = <<REDUCE;
\&    function(prev, current) {
\&        result = {count : 0};
\&        current.forEach(function(item) {
\&            result.count += item.count;
\&        });
\&        return result;
\&    }
\&    REDUCE
\&
\&    my $cmd = Tie::IxHash\->new("mapreduce" => "foo",
\&        "map" => $map,
\&        "reduce" => $reduce);
\&
\&    my $result = $db\->run_command($cmd);
.Ve
.PP
See the MongoDB documentation on MapReduce for more information
(<http://dochub.mongodb.org/core/mapreduce>).
.SH "QUERYING"
.IX Header "QUERYING"
.SS "Nested Fields"
.IX Subsection "Nested Fields"
MongoDB allows you to store deeply nested structures and then query for fields
within them using \fIdot-notation\fR.  For example, suppose we have a users
collection with documents that look like:
.PP
.Vb 9
\&    {
\&        "userId" => 12345,
\&        "address" => {
\&            "street" => "123 Main St",
\&            "city" => "Springfield",
\&            "state" => "MN",
\&            "zip" => "43213"
\&        }
\&    }
.Ve
.PP
If we want to query for all users from Springfield, we can do:
.PP
.Vb 1
\&    my $cursor = $users\->find({"address.city" => "Springfield"});
.Ve
.PP
This will search documents for an \*(L"address\*(R" field that is a subdocument and a
\&\*(L"city\*(R" field within the subdocument.
.SH "UPDATING"
.IX Header "UPDATING"
.SS "Positional Operator"
.IX Subsection "Positional Operator"
In MongoDB 1.3.4 and later, you can use positional operator, \f(CW\*(C`$\*(C'\fR, to update
elements of an array.  For instance, suppose you have an array of user
information and you want to update a user's name.
.PP
A sample document in JavaScript:
.PP
.Vb 12
\&    {
\&        "users" : [
\&            {
\&                "name" : "bill",
\&                "age" : 60
\&            },
\&            {
\&                "name" : "fred",
\&                "age" : 29
\&            },
\&        ]
\&    }
.Ve
.PP
The update:
.PP
.Vb 1
\&    $coll\->update({"users.name" => "fred"}, {\*(Aqusers.$.name\*(Aq => "george"});
.Ve
.PP
This will update the array so that the element containing \f(CW"name" => "fred"\fR
now has \f(CW"name" => "george"\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Kristina Chodorow <kristina@mongodb.org>
.IP "\(bu" 4
Mike Friedman <mike.friedman@10gen.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by 10gen, Inc..
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
